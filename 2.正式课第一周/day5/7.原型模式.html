<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 构造函数

   /* function Fn(a,b) {
        // 在构造函数中，跟this相关的都是当前实例的私有属性；
        this.a=a;
        this.b=b;
    }
    console.log(Fn.prototype.constructor===Fn);// {}
    Fn.prototype.getX = function () {
        console.log(this.a);
    }
    var f = new Fn(100,200);// {a:100,b:200,getX:f}
    var f1 = new Fn(300,400);//{a:300,b:400,getX:f}
    console.log(f);*/
    /*var f = new Fn;//  {a: 100, b: 200, getX: ƒ}
    var f1 = new Fn;// {a: 100, b: 200, getX: ƒ}
    console.log(f);// {a:100,b:200}
    console.log(f == f1);// false
    console.log(f.a == f1.a);
    console.log(f.getX == f1.getX);*/// false
   /* console.log(f.getX==f1.getX);
    f1.getX();
    console.log(f.__proto__ === Fn.prototype);
*/
    // 原型模式： 原型模式解决了公有属性的问题，把属性和方法放到父类的原型（prototype）属性上，那么父类产生的实例都可以调用父类原型上的方法；
   /* var  a = [12,34,9];
    var  b = [28,0.3,89];
    console.log(Array);
    console.log(a.push === b.push);
    a.push();
    b.push();*/


   // 1.每一个函数数据类型（普通函数、类）天生自带一个prototype属性，它的属性值是一个对象数据类型
    // 2. prototype的属性值天生自带一个constructor属性，constructor的属性值指向当前原型所属的类
    // 3. 每一个对象数据类型天生自带一个__proto__属性，它的属性值指向当前实例所属类的原型；

</script>
</body>
</html>